%%=============================================================================
%% Inleiding
%%=============================================================================

\chapter{JavaScript frameworks vergelijking}
\label{ch:onderzoek}

In dit hoofdstuk zal mijn onderzoek uitgebreid uigelegd worden. Alle criteria die hiervoor besproken zijn zullen hier vergeleken worden met elkaar. Hieruit zal later een conclusie genomen worden. In de praktische vergelijking zullen ook de test applicaties grondig verduidelijkt worden.

\section{Theoretische vergelijking}
\label{sec:theoretische_vergelijking}

In dit onderdeel zal de theoretische vergelijking gemaakt worden aan de hand van de literatuurstudie. We gaan alle vergelijking criteria die besproken zijn in Hoofdstuk \ref{sec:Theoretische_Vergelijking} hier behandelen.

Alle resultaten zijn aanwezig in tabel \ref{table:theoretische_vergelijking}. Hieruit kunnen we de volgende conclusies halen.

\begin{itemize}
	\item React en Vue zijn het populairst op GitHub. Dit betekend dat er waarschijnlijk voor React en Vue meer online resources te vinden zijn. We kunnen hier ook uit afleiden dat er meer libraries ondersteund zullen worden door React en Vue.
	\item Angular heeft meer zoekresultaten op Google trends en stackoverflow trends. Dit betekend dat er meer vragen over Angular gesteld maar ook beantwoord kunnen worden.
	\item Security zit ingebouwd in Angular. Bij React en Vue zal de developer zelf nog maatregelen moeten treffen om security op punt te stellen.
	\item Angular en React worden gebruikt door grote bedrijven. Hierdoor tonen zei dat ze vertrouwen hebben in dit framework en zal er een groter publiek naar deze frameworks getrokken worden.
	\item Angular legt een bepaald ontwerppatroon op bij de developer. React en Vue doen dit niet waardoor ze meer vrijheid creëren. In Angular kunnen er veel fouten voorkomen worden net door dit ontwerppatroon.
	\item Op alle andere vlakken scoren de drie frameworks gelijk.
\end{itemize}

\begin{table}[h]
	\centering
	\caption{Theoretische vergelijking}
	\label{table:theoretische_vergelijking}
	\begin{tabular}{|p{7cm}||p{2cm}|p{2cm}|p{2cm}|}
		\hline
		&Angular &Vue   &React \\ \hline \hline
		Wat zijn de resultaten op Google Trends van deze drie frameworks?
		&\multicolumn{3}{c|}{Figuur \ref{fig:google_trends}}\\ \hline
		Wat zijn de resultaten op StackOverflow Trends van deze drie frameworks?
		&\multicolumn{3}{c|}{Figuur \ref{fig:stackoverflow_trends}}\\ \hline
		Hoeveel GitHub watchers telt het framework? \autocite{github_front-end_????} 
		&3040     &4927  &5850 \\ \hline
		Voorkomt het framework Cross Site Request Forgery? \autocite{_angular_2018-1}
		&Ja         &Nee    &Nee \\ \hline
		Voorkomt het framework Cross Site Scripting? \autocite{_angular_2018-1}
		&Ja         &Nee    &Nee \\ \hline
		Bestaat er een tool om code te genereren?
		&Ja         &Ja     &Ja       \\ \hline
		Wordt het framework gebruikt door een grote organisatie? \autocite{_made_????} \autocite{_made_????-1}
		&Ja         &Geen kwaliteitsvolle bronnen &Ja \\ \hline
		Ondersteunt het framework mobiele apparaten?
		&Ja         &Ja     &Ja       \\ \hline
		Heeft de framework een specifiek ontwerp patroon waardoor het development van verschillende lagen of componenten makkelijker word?
		&Ja         &Nee   &Nee       \\ \hline
		Ondersteund het framework een component gebaseerde methodologie?
		&Ja         &Ja     &Ja       \\ \hline
		Ondersteund het framework unit tests? \autocite{_testing_2018} \autocite{_testing_2018-2} \autocite{_testing_2018-1}
		&Ja         &Ja     &Ja       \\ \hline
		Ondersteund het framework integratie tests?
		&Ja         &Ja     &Ja      \\  \hline
	\end{tabular}
\end{table}

\begin{figure}[h!]
	\caption{Angular, Vue en React google trends relatie \autocite{_google_2018}}
	\centering
	\includegraphics[width=1\textwidth]{img/googleTrends.png}
	\label{fig:google_trends}
\end{figure}

\begin{figure}[h!]
	\caption{Angular, Vue en React stackoverflow trends relatie \autocite{_stackoverflow_2018}}
	\centering
	\includegraphics[width=0.6\textwidth]{stackoverflowTrends.png}
	\label{fig:stackoverflow_trends}
\end{figure}


\section{Praktische vergelijking}
\label{sec:praktische_vergelijking}
In dit onderdeel worden alle praktische vergelijkingen gemaakt. Dit word gedaan door de resultaten van de performance tests en software complexiteit te vergelijken.

Om alle tests zo eerlijk en correct mogelijk te laten verlopen zullen we onze omgevingsfactoren gelijk stellen bij alle tests. De tests die uitgevoerd worden in dit onderzoek zijn uitgevoerd met volgende setup:

\begin{itemize}
	\item Windows 10 Home 64 bits (10.0, build16299)
	\item Intel Core i7-4790 CPU @ 3.6GHz
	\item 8GB RAM
	\item Google Chrome 66.0.3359.139
\end{itemize}

Bij elke test zullen alle mogelijke processen op de pc gestopt worden behalve de browser.

Alle tests worden natuurlijk uitgevoerd op dezelfde applicaties. De code van deze applicaties is te vinden in bijlage \ref{ch:applicaties}.

\subsection{Grootte}
\label{sec:grootte}

Hier zullen de filesizes besproken worden die in de netwerk tab van de browser gedownload moeten worden. De software die hiervoor gebruikt werd is Google Chrome developer tools netwerk tab. Er werd hier geen gebruik gemaakt van een shortlist omdat deze keuze de meest logische is. Andere software zal ook hetzelfde resultaat geven. Er zijn ook geen voor of nadelen aan.

In tabel \ref{table:file_sizes} zien we dat React en Vue zeer sterk bij elkaar liggen met amper 30 kilobytes verschil. Angular daarentegen heeft een geweldige grootte van 3160 kilobytes. De reden hiervoor is omdat Angular een compleet framework meestuurd. Als deze applicaties groter zouden zijn dan zou het verschil kleiner geweest zijn. Dit is iets waar in het begin van deze tests geen rekening mee gehouden is maar waar wel veel uit geleerd kan worden.

\begin{table}[h]
	\centering
	\caption{Grootte in kilobytes}
	\label{table:file_sizes}
	\begin{tabular}{|c|c|c|} \hline
		Angular &Vue   &React \\ \hline
		3160     &90.3  &128.4 \\ \hline
	\end{tabular}
\end{table}

\subsection{First meaningfull paint}
\label{sec:first_meaningfull_paint}

In dit onderdeel zullen we de first meaningfull paint resultaten bespreken. Elke test is tien keer uitgevoerd op elke pagina. De first meaningfull paint is de tijd waarop de pagina het eerst zichtbaar wordt. Deze test werd maar tien keer uitgevoerd omdat deze waarde nooit veel zal verschillen op elke computer in perfecte omstandigheden. De software die hiervoor gebruikt werd is lighthouse audits van Google Chrome developer tools. De reden waarom er niet geopteerd word voor een shortlist is omdat google lighthouse de enigen zijn die deze functionaliteit op het moment van schrijven bieden.

In tabel \ref{table:first_meaningfull_paint} zien we dat Vue en React weer zeer sterke competitie voeren met elkaar. Angular is hier ook weer de uitzondering met tijden die tien keer langer duren dan Vue en React. De reden hiervoor is omdat de software die gebruikt is om deze tijden te meten langer zal laden hoe groter de grootte van het bestand is. Dit is een gevolg uit de test in het vorige hoofdstuk \ref{sec:grootte}.

\begin{table}[h]
	\centering
	\caption{First meaningfull paint in milliseconden}
	\label{table:first_meaningfull_paint}
	\begin{tabular}{|c|c|c|c|} \hline
									&Angular       &Vue        &React      \\ \hline
		gemiddelde			&20270.00     &1845.00  &2304.00 \\ \hline
		minimuum			&19890.00     &1810.00  &2200.00  \\ \hline
		maximuum			&20870.00    &1890.00  &2500.00 \\ \hline
		mediaan				   &20230.00    &1840.00  &2295.00 \\ \hline
		standaarddeviatie &340.94        &24.187    &84.758    \\ \hline
	\end{tabular}
\end{table}

\subsection{Tarief}
\label{sec:tarief}

In dit onderdeel zullen we het tarief meten van elk framework. Hiervoor zijn zelf benchmark tests gemaakt die de tijd zullen meten op een bepaald aantal elementen in te laden. We gaan dit meten voor 100, 500 en 1000 elementen. Hieruit gaan we dan concluderen of er een bepaald framework sneller is dan een ander en waarom. Ten eerste zal de code van de benchmarks besproken worden.

\subsubsection{Benchmark script}
\label{sec:benchmark_script}

De hele benchmark pagina bestaat uit twee delen. De linkerzijde bevat de lijst met benchmarks en resultaten. Rechts is er een iFrame waarin de webapplicaties met verschillende frameworks één voor één ingeladen kunnen worden. De hele interface is te zien in figuur \ref{fig:benchmark_empty} en figuur \ref{fig:benchmark_completed}.


\begin{figure}[h!]
	\caption{Benchmark interface voor de tests}
	\centering
	\includegraphics[width=0.8\textwidth]{benchmarksInitial.png}
	\label{fig:benchmark_empty}
\end{figure}
\begin{figure}[h!]
	\caption{Benchmark interface met resultaten}
	\centering
	\includegraphics[width=0.8\textwidth]{benchmarksCompleted.png}
	\label{fig:benchmark_completed}
\end{figure}

Het script bestaat uit verschillende delen. Ten eerste is er een array waar de test in beschreven worden. Hierin staat voor welk framework het is, de naam en hoeveel items de test moet toevoegen. Hiernaast ook nog enkele veriabelen die nodig zijn om tijd te berekenen. Een voorbeeld van zo een test kan je zien in listing 4.1. Het volledige script is bijgevoegd in de bijlage \ref{ch:benchmark}.

\codefragment{code/BenchmarkTests.js}{Array dat tests definieert}

Om een test te starten zal de start methode eerst opgeroepen worden. Dit zorgt ervoor dat er in de iFrame een methode geïntjecteerd word die de applicatie kan oproepen. De start methode kan je zien in listing 4.2.

\codefragment{code/BenchmarkStart.js}{Start methode}

Zoals te zien is zal de start methode op het einde de next methode oproepen van de test (Listing 4.3). Deze next methode zal ervoor zorgen dat er een tekst in de input field geplaatst wordt. Hierna zal de timer starten om de tijd te meten. Vlak na dat de timer start zal een tweede timer gezet worden om te meten hoe lang het duurt om de timer te starten en te stoppen. Dit zullen we gebruiken om de nauwkeurigheid hiervant te meten. Het script zal dan simuleren dat de enter toets ingedrukt wordt. De applicatie zal dit opvangen en het renderen gaat van start. Als het renderen gedaan is zal in de correcte lifecycle hook de functie opgeroepen worden die we eerder in de iFrame geïnjecteerd hebben. Nu heeft de applicatie gesignaleerd aan ons benchmark script dat het renderen klaar is. Ten slotte stopt de timer en zal next terug opgeroepen worden. Deze sequentie zal opgeroepen worden tot het volledige aantal elementen toegevoegd zijn. De next methode zal dit merken en de finish methode zal opgeroepen worden (Listing 4.4). Deze berekend alle nodige waarden en ten slotte zal de volgende test van start gaan.

\codefragment{code/BenchmarkNext.js}{Next methode}

\codefragment{code/BenchmarkFinish.js}{Finish methode}

Dit hele process werkt met veel asynchrone processen en kan dus niet gewoon sequentieel behandeld worden. Om de iteraties en tests in de juiste volgorde te laten verlopen wordt er gebruik gemaakt van generator functions. Deze zijn te zien in listing 4.5. Deze functies staan in om de iFrame te herladen en alle resultaten op te slaan in de localStorage.

\codefragment{code/BenchmarkGenerators.js}{Iteratie generator en test generator}

\subsubsection{Resultaten}
\label{sec:resultaten_benchmarks}

In dit onderdeel zullen de resultaten enkel in beknopte vorm weergegeven worden. Een complete set van alle individuele resultaten is te vinden in de bijlage \ref{resultaten}.

Ten eerste zal ik alle resultaten van de drie tests weergeven in tabelvorm. Hierna zal ik meer duidelijkheid proberen scheppen door ze in geschikte grafieken weer te geven.

\begin{table}[h]
	\centering
	\caption{Resultaten 100 elementen inladen in milliseconden}
	\label{table:resultaten_100_elementen}
	\begin{tabular}{|c|c|c|c|} \hline
		                           &Angular     &Vue        &React      \\ \hline
		gemiddelde			&63.685     &100.755  &47.173 \\ \hline
		minimuum			&59.400     &83.800  &44.900 \\ \hline
		maximuum			&69.900    &111.900  &51.800 \\ \hline
		mediaan				   &63.500    &101.200  &47.100 \\ \hline
		standaarddeviatie &1.965        &5.078    &1.256    \\ \hline
	\end{tabular}
\end{table}

\begin{table}[h]
	\centering
	\caption{Resultaten 500 elementen inladen in milliseconden}
	\label{table:resultaten_500_elementen}
	\begin{tabular}{|c|c|c|c|} \hline
								   &Angular     &Vue        &React      \\ \hline
		gemiddelde			&426.149     &701.206  &239.316 \\ \hline
		minimuum			&404.600    &626.500  &226.600 \\ \hline
		maximuum			&456.000    &774.700  &251.700 \\ \hline
		mediaan				   &424.300    &702.700  &239.150 \\ \hline
		standaarddeviatie &9.380       &28.027    &4.666    \\ \hline
	\end{tabular}
\end{table}

\begin{table}[h]
\centering
\caption{Resultaten 1000 elementen inladen in milliseconden}
\label{table:resultaten_1000_elementen}
\begin{tabular}{|c|c|c|c|} \hline
		   						&Angular     &Vue        &React      \\ \hline
	gemiddelde			&1370.683     &2305.653  &682.043 \\ \hline
	minimuum			&1315.300    &2135.800  &660.700 \\ \hline
	maximuum			&1467.400    &2859.400  &725.300 \\ \hline
	mediaan				   &1363.000    &2285.150  &680.150 \\ \hline
	standaarddeviatie &33.224       &110.786    &12.969    \\ \hline
\end{tabular}
\end{table}

\begin{figure}[h!]
	\caption{Benchmark interface met resultaten}
	\centering
	\includegraphics[width=0.6\textwidth]{Add100Items.png}
	\label{fig:resultaten_100_elementen}
\end{figure}
\begin{figure}[h!]
	\caption{Benchmark interface met resultaten}
	\centering
	\includegraphics[width=0.6\textwidth]{Add500Items.png}
	\label{fig:resultaten_500_elementen}
\end{figure}
\begin{figure}[h!]
	\caption{Benchmark interface met resultaten}
	\centering
	\includegraphics[width=0.6\textwidth]{Add1000Items.png}
	\label{fig:resultaten_1000_elementen}
\end{figure}

Met deze informatie is er één framework dat er ver bovenuitsteekt. React is namelijk veel sneller in alles. Ook is de standaard afwijking zeer miniem. Dit betekend dat React een zeer stabiel framework is. Als we verderkijken naar figuur \ref{fig:resultaten_gemiddelden} zien we nog een belangrijke trend. De resultaten bij elk framework zijn niet recht evenredig. Hoe meer elementen een framework moet renderen hoe langer dit duurt. De relatie tussen de tijd en het aantal elementen is exponentieel. 

\begin{figure}[h!]
	\caption{Gemiddelden in staafdiagram ten opzichte van elkaar}
	\centering
	\includegraphics[width=0.6\textwidth]{Gemiddelden.png}
	\label{fig:resultaten_gemiddelden}
\end{figure}






